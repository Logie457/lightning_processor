//! Tools for encoding and decoding instructions into and from an intuitive structure.
//! 
//! The instruction encoding and decoding format involved an intermediate format. Instructions involve 2 mandatory 
//! driver bytes and an optional register byte. 
//! - The driver bytes are encoded & decoded through the [Driver] structure which depends on the [Driver0Encoding] & 
//! [Driver1Encoding] traits.
//! - The register byte is encoded & decoded through the [Registers] structure which depends on the [RegisterEncoding]
//! trait.
//! 
//! Once the instruction data has been decoded into the intermediates, data is conditioned and extracted into a more 
//! intuitive instruction structure.
//! 
//! Binary instruction format is as follows.
//! 
//! | Required | Byte Name | Field               | Size     | Description                                                     |
//! | -------- | --------- | ------------------- | -------- | --------------------------------------------------------------- |
//! | Yes      | Driver 0  | Extension           | 6 bits   | Operation's extension.                                          |
//! | Yes      | Driver 0  | Synchronise         | 1 bits   | Ensure execution is synchronous in respect to other processors. |
//! | Yes      | Driver 0  | Destination Dynamic | 1 bits   | Base the result location off the dynamic operand.               |
//! | Yes      | Driver 1  | Operation           | 4 bits   | Operation to execute.                                           |
//! | Yes      | Driver 1  | Addressing          | 2 bits   | Dynamic operand's addressing method.                            |
//! | Yes      | Driver 1  | Immediate Exponent  | 2 bits   | Immediate input size power on 2.                                | 
//! | No       | Register  | Width               | 2 bits   | Operating data size.                                            |
//! | No       | Register  | Static Operand      | 3 bits   | Static register operand.                                        |
//! | No       | Register  | Dynamic Operand     | 3 bits   | Dynamically addressable operand.                                |
//!
//! Immediate 0..8 quantized to 0, 2, 4 and 8.

#![allow(clippy::unusual_byte_groupings)]

pub mod operand;
pub mod operation;

use std::io;
use std::io::Read;
use crate::number;
use crate::instruction::operand::{AllPresent, Dynamic, FromCodesError, Operand, Operands};
use crate::instruction::operation::{Coded, Extension, ExtensionFromCodeInvalid, Operation};

// region: Binary processor bit masks
pub const DRIVER0_EXTENSION_MASK           : u8 = 0b111111_0_0;
pub const DRIVER0_SYNCHRONISE_MASK         : u8 = 0b000000_1_0;
pub const DRIVER0_DYNAMIC_DESTINATION      : u8 = 0b000000_0_1;
pub const DRIVER1_OPERATION_MASK           : u8 = 0b1111_00_00;
pub const DRIVER1_ADDRESSING_MASK          : u8 = 0b0000_11_00;
pub const DRIVER1_ADDRESSING_PARAMETER_MASK: u8 = 0b0000_00_11;
pub const REGISTERS_WIDTH_MASK             : u8 = 0b11_000_000;
pub const REGISTERS_STATIC_OPERAND_MASK    : u8 = 0b00_111_000;
pub const REGISTERS_DYNAMIC_OPERAND_MASK   : u8 = 0b00_000_111;
// endregion

/// Structured data from the driver bytes. All data generated by inherent functions are unchecked. Contains utility
/// functions for coding driver bytes.
pub struct Driver {
	/// Operation extension
	pub extension: u8,
	pub operation: u8,
	pub synchronise: bool,
	/// Whether to store the data where the dynamic operand points if its addressing mode supports it.
	pub dynamic_destination: bool,
	/// Addressing mode of the dynamic operand
	pub addressing: u8,
	/// To determine how many bytes the immediate is.
	pub immediate_exponent: u8
}

impl Driver {
	/// Decode the driver bytes into an instance of a driver.
	/// ```
	/// use atln_processor::instruction::Driver;
	/// 
	/// let driver = Driver::from_encoded([0b001010_0_1, 0b1111_10_01]);
	///
	/// // Driver 0
	/// assert_eq!(driver.extension, 0b001010);
	/// assert!(!driver.synchronise);
	/// assert!(driver.dynamic_destination);
	///
	/// // Driver 1
	/// assert_eq!(driver.operation, 0b1111);
	/// assert_eq!(driver.addressing, 0b10);
	/// assert_eq!(driver.immediate_exponent, 0b1);
	/// ```
	pub fn from_encoded(bytes: [u8; 2]) -> Self {
		let driver0 = bytes[0];
		let driver1 = bytes[1];

		Driver {
			extension: driver0.extract_extension(),
			operation: driver1.extract_operation(),
			synchronise: driver0.extract_synchronise(),
			dynamic_destination: driver0.extract_dynamic_destination(),
			addressing: driver1.extract_addressing(),
			immediate_exponent: driver1.extract_immediate_exponent(),
		}
	}

	pub fn encode(&self) -> [u8; 2] {
		let mut driver0 = 0.set_extension(self.extension);
		driver0 = driver0.set_synchronise(self.synchronise);
		driver0 = driver0.set_dynamic_destination(self.dynamic_destination);

		let mut driver1 = 0.set_operation(self.operation);
		driver1 = driver1.set_addressing(self.addressing);
		driver1 = driver1.set_immediate_exponent(self.immediate_exponent);

		[driver0, driver1]
	}
}

// region: Uint driver traits
pub trait Driver0Encoding {
	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	///
	/// assert_eq!(0b001101_0_0_u8.extract_extension(), 0b00_001101);
	/// assert_eq!(0b101010_0_1_u8.extract_extension(), 0b00_101010);
	///```
	fn extract_extension(self) -> u8;

	/// Only the first 6 bits of the extension is used.
	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	/// 
	/// assert_eq!(0b000000_0_1_u8.set_extension(10), 0b001010_0_1);
	/// assert_eq!(0b101100_0_0_u8.set_extension(0b101100), 0b101100_0_0);
	/// assert_eq!(0b101100_1_0_u8.set_extension(0b101100), 0b101100_1_0);
	///
	/// // Truncating extension
	/// assert_eq!(0b00000000_0_0_u8.set_extension(0b11_111111), 0b111111_0_0);
	/// assert_eq!(0b00000000_0_1_u8.set_extension(0b11_111110), 0b111110_0_1);
	/// ```
	fn set_extension(self, extension: u8) -> u8;

	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	///
	/// assert!(0b000000_1_0_u8.extract_synchronise());
	/// assert!(!0b000000_0_0_u8.extract_synchronise());
	/// assert!(0b001010_1_1_u8.extract_synchronise());
	/// assert!(!0b001010_0_1_u8.extract_synchronise());
	/// ```
	fn extract_synchronise(self) -> bool;

	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	/// assert_eq!(0b000000_0_0_u8.set_synchronise(true), 0b000000_1_0);
	/// assert_eq!(0b000000_1_0_u8.set_synchronise(false), 0b000000_0_0);
	/// assert_eq!(0b000000_0_1_u8.set_synchronise(true), 0b000000_1_1);
	/// assert_eq!(0b111111_0_0_u8.set_synchronise(false), 0b111111_0_0);
	/// ```
	fn set_synchronise(self, lock: bool) -> u8;

	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	/// 
	/// assert!(0b000000_0_1_u8.extract_dynamic_destination());
	/// assert!(!0b000000_0_0_u8.extract_dynamic_destination());
	/// assert!(0b000000_1_1_u8.extract_dynamic_destination());
	/// assert!(!0b000000_1_0_u8.extract_dynamic_destination());
	/// ```
	fn extract_dynamic_destination(self) -> bool;

	/// ```
	/// use atln_processor::instruction::Driver0Encoding;
	/// 
	/// assert_eq!(0b000000_0_0_u8.set_dynamic_destination(true), 0b000000_0_1);
	/// assert_eq!(0b000000_1_0_u8.set_dynamic_destination(true), 0b000000_1_1);
	/// assert_eq!(0b000000_0_1_u8.set_dynamic_destination(false), 0b000000_0_0);
	/// assert_eq!(0b000000_1_1_u8.set_dynamic_destination(false), 0b000000_1_0);
	/// ```
	fn set_dynamic_destination(self, dynamic_destination: bool) -> u8;
}

impl Driver0Encoding for u8 {
	fn extract_extension(self) -> u8 {
		(DRIVER0_EXTENSION_MASK & self) >> 2
	}

	/// Only the first 6 bits of the extension is used.
	fn set_extension(self, extension: u8) -> u8 {
		let layer = (0b00_111111 & extension) << 2;
		(!DRIVER0_EXTENSION_MASK & self) | layer
	}

	fn extract_synchronise(self) -> bool {
		// Value will always be 1 bit.
		let bit = (DRIVER0_SYNCHRONISE_MASK & self) >> 1;
		bit == 1
	}

	fn set_synchronise(self, lock: bool) -> u8 {
		let layer = (lock as u8) << 1;
		(!DRIVER0_SYNCHRONISE_MASK & self) | layer
	}

	fn extract_dynamic_destination(self) -> bool {
		// Value will always be 1 bit.
		(DRIVER0_DYNAMIC_DESTINATION & self) == 1
	}

	fn set_dynamic_destination(self, dynamic_destination: bool) -> u8 {
		(!DRIVER0_DYNAMIC_DESTINATION & self) | dynamic_destination as u8
	}
}

pub trait Driver1Encoding {
	fn extract_operation(self) -> u8;

	/// Only the first 4 bits of the operation is used.
	fn set_operation(self, operation: u8) -> u8;

	fn extract_addressing(self) -> u8;

	/// Only the first 2 bits of the addressing is used.
	fn set_addressing(self, addressing: u8) -> u8;

	fn extract_immediate_exponent(self) -> u8;

	/// Only the first 2 bits of the addressing is used.
	fn set_immediate_exponent(self, immediate_exponent: u8) -> u8;
}

impl Driver1Encoding for u8 {
	fn extract_operation(self) -> u8 {
		(DRIVER1_OPERATION_MASK & self) >> 4
	}

	/// Only the first 4 bits of the operation is used.
	fn set_operation(self, operation: u8) -> u8 {
		let layer = (0b0000_1111 & operation) << 4;
		(!DRIVER1_OPERATION_MASK & self) | layer
	}

	fn extract_addressing(self) -> u8 {
		(DRIVER1_ADDRESSING_MASK & self) >> 2
	}

	/// Only the first 2 bits of the addressing is used.
	fn set_addressing(self, addressing: u8) -> u8 {
		let layer = (0b_000000_11 & addressing) << 2;
		(!DRIVER1_ADDRESSING_MASK & self) | layer
	}

	fn extract_immediate_exponent(self) -> u8 {
		DRIVER1_ADDRESSING_PARAMETER_MASK & self
	}

	/// Only the first 2 bits of the addressing is used.
	fn set_immediate_exponent(self, immediate_exponent: u8) -> u8 {
		let layer = 0b000000_11 & immediate_exponent;
		(!DRIVER1_ADDRESSING_PARAMETER_MASK & self) | layer
	}
}
// endregion

/// The operand to dereference store the operation result in.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Destination {
	Static,
	Dynamic
}

/// Register byte encoding.
pub struct Registers {
	pub width: u8,
	pub x_static: u8,
	pub x_dynamic: u8
}

impl Registers {
	pub fn from_encoded(encoded: u8) -> Self {
		Self {
			width: encoded.extract_width(),
			x_static: encoded.extract_static(),
			x_dynamic: encoded.extract_static()
		}
	}

	pub fn encode(&self) -> u8 {
		let mut encoded = 0.set_width(self.width);
		encoded = encoded.set_static(self.x_static);
		encoded.set_dynamic(self.x_dynamic)
	}
}

// region: Uint traits
pub trait RegistersEncoding {
	fn extract_width(self) -> u8;

	/// Only first 2 bits are used.
	fn set_width(self, width: u8) -> u8;

	fn extract_static(self) -> u8;

	/// Only first 3 bits are used.
	fn set_static(self, x_static: u8) -> u8;

	fn extract_dynamic(self) -> u8;

	/// Only first 3 bits are used.
	fn set_dynamic(self, dynamic: u8) -> u8;
}

impl RegistersEncoding for u8 {
	fn extract_width(self) -> u8 {
		(REGISTERS_WIDTH_MASK & self) >> 6
	}

	/// Only first 2 bits are used.
	fn set_width(self, width: u8) -> u8 {
		let layer = (0b000000_11 & width) << 6;
		(!REGISTERS_WIDTH_MASK & self) | layer
	}

	fn extract_static(self) -> u8 {
		(REGISTERS_STATIC_OPERAND_MASK & self) >> 3
	}

	/// Only first 3 bits are used.
	fn set_static(self, x_static: u8) -> u8 {
		let layer = (0b00000_111 & x_static) << 3;
		(!REGISTERS_STATIC_OPERAND_MASK & self) | layer
	}

	fn extract_dynamic(self) -> u8 {
		REGISTERS_DYNAMIC_OPERAND_MASK & self
	}

	/// Only first 3 bits are used.
	fn set_dynamic(self, dynamic: u8) -> u8 {
		let layer = 0b00000_111 & dynamic;
		(!REGISTERS_DYNAMIC_OPERAND_MASK & self) | layer
	}
}
// endregion

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Data {
	/// Width of operands when dereferenced and for storing result.
	pub width: number::Type,
	pub destination: Destination,
	pub synchronise: bool,
	pub operands: Operands
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Instruction {
	pub extension: Extension,
	pub data: Option<Data>
}

#[derive(Debug)]
pub enum DecodeError {
	/// Stream failed to read.
	StreamRead(io::Error),
	/// Not enough bytes.
	Length,
	/// The extension and or operation are invalid.
	InvalidCode(ExtensionFromCodeInvalid),
	/// Error caused from interpreting the dynamic operand
	Dynamic(FromCodesError),
	/// Both the synchronous state and register addressing mode were used which is not allowed.
	SynchronousRegister
}

/// Caused by using a destination which corresponds to an operand that is not provided.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DestinationError {
	/// No data included.
	Data,
	/// The static operand wasn't present.
	Static,
	/// The dynamic operand wasn't present.
	Dynamic
}

impl Instruction {
	/// Use the driver, registers, and immediate to encode into a dynamic number of bytes. Encoding is variable 
	/// length. The data is not validated here. To use an immediate, registers must be of the [Some] variant. If an 
	/// immediate is [Some] and registers is [None] then [None] will also be returned.
	pub fn encode_driver_registers_immediate(driver: &Driver, registers: Option<&Registers>, immediate: Option<&number::Data>) -> Option<Vec<u8>> {
		let mut encoded = Vec::new();

		encoded.extend(driver.encode());
		if let Some(registers) = registers { 
			encoded.push(registers.encode());
			if let Some(immediate) = immediate { encoded.extend(immediate.to_le_bytes()); }
		} else if immediate.is_some() { return None; }
		
		Some(encoded)
	}

	// Decode an encoded binary stream into a processor instruction.
	pub fn from_encoded(stream: &mut impl Read) -> Result<Self, DecodeError> {
		// Decode driver bytes.
		let mut encoded_driver = [0u8; 2];

		match stream.read(&mut encoded_driver) {
			Ok(length) => if length != encoded_driver.len() { return Err(DecodeError::Length) },
			Err(error) => return Err(DecodeError::StreamRead(error))
		};

		let driver = Driver::from_encoded(encoded_driver);

		let mut extension =  match Extension::from_codes(driver.extension, driver.operation) {
			Ok(operation) => operation,
			Err(error) => return Err(DecodeError::InvalidCode(error))
		};

		// Decode data bytes.
		let mut data: Option<Data> = None;
		let operation = extension.operation();

		if operation.expects_operand() {
			// Decode registers byte.
			let mut data_encoded = [0u8; 1];
			match stream.read(&mut data_encoded) {
				Ok(length) => if length != data_encoded.len() { return Err(DecodeError::Length); },
				Err(error) => return Err(DecodeError::StreamRead(error))
			};

			let registers = Registers::from_encoded(data_encoded[0]);

			let x_dynamic = if operation.expects_dynamic() {
				Some(match Dynamic::from_codes(registers.x_dynamic, driver.addressing, driver
					.immediate_exponent, stream) {
					Ok(operand) => operand,
					Err(error) => return Err(DecodeError::Dynamic(error))
				})
			} else { None };

			// Do not allow the processor to be synchronous and use the register or constant addressing mode in the same
			// core. This is incompatible as the registers are localized to each processor and synchronous 
			// instructions are meant to allow memory actions to be predictable between multiple processors.
			if let Some(value) = &x_dynamic && let Dynamic::Register(_) = value && driver.synchronise { return Err(DecodeError::SynchronousRegister) }

			// Construct operand field.
			let operands = if operation.expects_all() {
				Operands::AllPresent(AllPresent {
					x_static: registers.x_static,
					x_dynamic: x_dynamic.unwrap()
				})
			} else if operation.expects_only_static() {
				Operands::Static(registers.x_static)
			} else if operation.expects_only_dynamic() {
				Operands::Dynamic(x_dynamic.unwrap())
			} else {
				unreachable!()
			};

			// Construct data.
			data = Some(Data {
				width: number::Type::from_exponent(registers.width).unwrap(),
				destination: if driver.dynamic_destination { Destination::Dynamic } else { Destination::Static },
				synchronise: driver.synchronise,
				operands
			})
		}

		// Construction
		Ok(Self {
			extension,
			data
		})
	}
	
	pub fn encode(&mut self) -> Vec<u8> {
		let mut synchronise = false;
		let mut dynamic_destination = false;
		let mut addressing = 0;
		let mut immediate_exponent = 0;
		let mut registers: Option<Registers> = None;
		let mut immediate: Option<number::Data> = None;
		
		if let Some(data) = &self.data { 
			synchronise = data.synchronise;
			dynamic_destination = match data.destination {
				Destination::Dynamic => true,
				Destination::Static => false
			};
			
			let mut x_dynamic_code = 0;
			if let Some(x_dynamic) = data.operands.x_dynamic() {
				x_dynamic_code = x_dynamic.register().unwrap_or(0);
				immediate = match x_dynamic.immediate() {
					Some(value) => Some(value.clone()),
					None => None
				};
				
				if let Some(immediate) = x_dynamic.immediate() { immediate_exponent = immediate.clone().exponent() }
				addressing = x_dynamic.addressing();
			}
			
			registers = Some(Registers {
				width: data.width.exponent(),
				x_static: data.operands.x_static().unwrap_or(0),
				x_dynamic: x_dynamic_code
			});
		} 
		
		let driver = Driver {
			extension: self.extension.code(),
			operation: self.extension.operation().code(),
			synchronise,
			dynamic_destination,
			addressing,
			immediate_exponent
		};
		
		// Unwrapping should not fail because the processor is a controlled environment.
		if let Some(registers) = registers {
			if let Some(immediate) = immediate { Instruction::encode_driver_registers_immediate(&driver, Some(&registers), Some(&immediate)).unwrap() } 
			else { Instruction::encode_driver_registers_immediate(&driver, Some(&registers), None).unwrap() }
		} else { Instruction::encode_driver_registers_immediate(&driver, None, None).unwrap() }
	}

	/// Get the operand that the destination property corresponds to.
	pub fn destination(&self) -> Result<Operand, DestinationError> {
		let data = match &self.data {
			Some(data) => data,
			None => return Err(DestinationError::Data)
		};

		Ok(match data.destination {
			Destination::Static => match data.operands.x_static() {
				Some(x_static) => Operand::Static(x_static),
				None => return Err(DestinationError::Static)
			},
			Destination::Dynamic => match data.operands.x_dynamic() {
				Some(x_dynamic) => Operand::Dynamic(x_dynamic.clone()),
				None => return Err(DestinationError::Dynamic)
			}
		})
	}
}
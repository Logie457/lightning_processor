//! Binary instruction format is as follows.
//!
//! Driver 0:
//! - Extension: Operation's extension.
//! - Synchronise: Ensure execution is synchronous in respect to other processors.
//! - Destination Dynamic: Base the result location off the dynamic operand.
//! 
//! Driver 1
//! - Operation: Operation to execute.
//! - Addressing: Dynamic operand's addressing method.
//! - Addressing Parameter: Addressing method's control parameter.
//! 
//! Data:
//! - Width: Operating data size.
//! - Static Operand: Static register operand.
//! - Dynamic Operand: Dynamically addressable operand.
//! 
//! Immediate 0..8 quantized to 0, 2, 4 and 8.

#![allow(clippy::unusual_byte_groupings)]

pub mod absolute;
pub mod operand;
pub mod operation;

use std::io;
use std::io::Read;
use crate::operand::{Operand, Operands};
use crate::operation::{Extension, ExtensionFromCodeInvalid};

// region: Binary instruction bit masks
pub const DRIVER0_EXTENSION_MASK           : u8 = 0b111111_0_0;
pub const DRIVER0_SYNCHRONISE_MASK         : u8 = 0b000000_1_0;
pub const DRIVER0_DYNAMIC_DESTINATION      : u8 = 0b000000_0_1;
pub const DRIVER1_OPERATION_MASK           : u8 = 0b1111_00_00;
pub const DRIVER1_ADDRESSING_MASK          : u8 = 0b0000_11_00;
pub const DRIVER1_ADDRESSING_PARAMETER_MASK: u8 = 0b0000_00_11;
pub const DATA_WIDTH_MASK                  : u8 = 0b11_000_000;
pub const DATA_STATIC_OPERAND_MASK         : u8 = 0b00_111_000;
pub const DATA_DYNAMIC_OPERAND_MASK        : u8 = 0b00_000_111;
// endregion

/// Structured data from the driver bytes. All data generated by inherent functions are unchecked. Contains utility 
/// functions for coding driver bytes. 
pub struct Driver {
    /// Operation extension
    pub extension: u8,
    pub operation: u8,
    /// Whether the instruction should be synchronously executed in respect to other parallel processors. 
    pub synchronise: bool,
    /// Whether to store the data where the dynamic operand points if its addressing mode supports it.
    pub dynamic_destination: bool,
    /// Addressing mode of the dynamic operand
    pub addressing: u8,
    /// Parameter for the addressing mode.
    pub addressing_parameter: u8
}

impl Driver {
    pub fn extract_extension(driver0: u8) -> u8 {
        (DRIVER0_EXTENSION_MASK & driver0) >> 2
    }

    /// Only the first 6 bits of the extension is used.
    pub fn set_extension(driver0: u8, extension: u8) -> u8 {
        let layer = (0b00_111111 & extension) << 2;
        (!DRIVER0_EXTENSION_MASK & driver0) | layer
    }

    pub fn extract_synchronise(driver0: u8) -> bool {
        // Value will always be 1 bit.
        let bit = (DRIVER0_SYNCHRONISE_MASK & driver0) >> 1;
        bit == 1
    }

    pub fn set_synchronise(driver0: u8, lock: bool) -> u8 {
        let layer = (lock as u8) << 1;
        (!DRIVER0_SYNCHRONISE_MASK & driver0) | layer
    }

    pub fn extract_dynamic_destination(driver0: u8) -> bool {
        // Value will always be 1 bit.
        (DRIVER0_DYNAMIC_DESTINATION & driver0) == 1
    }

    pub fn set_dynamic_destination(driver0: u8, dynamic_destination: bool) -> u8 {
        (!DRIVER0_DYNAMIC_DESTINATION & driver0) | dynamic_destination as u8
    }

    pub fn extract_operation(driver1: u8) -> u8 {
        (DRIVER1_OPERATION_MASK & driver1) >> 4
    }

    /// Only the first 4 bits of the operation is used.
    pub fn set_operation(driver1: u8, operation: u8) -> u8 {
        let layer = (0b0000_1111 & operation) << 4;
        (!DRIVER1_OPERATION_MASK & driver1) | layer
    }

    pub fn extract_addressing(driver1: u8) -> u8 {
        (DRIVER1_ADDRESSING_MASK & driver1) >> 2
    }

    /// Only the first 2 bits of the addressing is used.
    pub fn set_addressing(driver1: u8, addressing: u8) -> u8 {
        let layer = (0b_000000_11 & addressing) << 2;
        (!DRIVER1_ADDRESSING_MASK & driver1) | layer
    }

    pub fn extract_addressing_parameter(driver1: u8) -> u8 {
        DRIVER1_ADDRESSING_PARAMETER_MASK & driver1
    }

    /// Only the first 2 bits of the addressing is used.
    pub fn set_addressing_parameter(driver1: u8, addressing_parameter: u8) -> u8 {
        let layer = 0b000000_11 & addressing_parameter;
        (!DRIVER1_ADDRESSING_PARAMETER_MASK & driver1) | layer
    }

    pub fn from_encoded(bytes: [u8; 2]) -> Self {
        let driver0 = bytes[0];
        let driver1 = bytes[1];

        Driver {
            extension: Driver::extract_extension(driver0),
            operation: Driver::extract_operation(driver1),
            synchronise: Driver::extract_synchronise(driver0),
            dynamic_destination: Driver::extract_dynamic_destination(driver0),
            addressing: Driver::extract_addressing(driver1),
            addressing_parameter: Driver::extract_addressing_parameter(driver1),
        }
    }

    pub fn encode(&self) -> [u8; 2] {
        let mut driver0 = Driver::set_extension(0, self.extension);
        driver0 = Driver::set_synchronise(driver0, self.synchronise);
        driver0 = Driver::set_dynamic_destination(driver0, self.dynamic_destination);

        let mut driver1 = Driver::set_operation(0, self.operation);
        driver1 = Driver::set_addressing(driver1, self.addressing);
        driver1 = Driver::set_addressing_parameter(driver1, self.addressing_parameter);

        [driver0, driver1]
    }
}

/// The operand to dereference store the operation result in.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Destination {
    Static,
    Dynamic
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Instruction {
    pub operation: Extension,
    /// Width of operands when dereferenced and for storing result.
    pub width: absolute::Type,
    pub destination: Destination,
    pub operands: Operands,
}

#[derive(Debug)]
pub enum DecodeError {
    /// Caused by the stream.
    Stream(io::Error),
    /// The extension of operation code was invalid.
    InvalidCode(ExtensionFromCodeInvalid)
}

/// Caused by using a destination which corresponds to an operand that is not provided.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DestinationError {
    /// The static operand wasn't present.
    Static,
    /// The dynamic operand wasn't present.
    Dynamic
}

impl Instruction {
    // Decode a binary stream to update this instruction with the new data.
    pub fn decode(&mut self, stream: &mut dyn Read) -> Result<(), DecodeError> {
        let buffer = [0u8; 1];

        // Decode driver 0


        Ok(())
    }

    /// Get the operand that the destination property corresponds to.
    pub fn destination(&self) -> Result<Operand, DestinationError> {
        Ok(match self.destination {
            Destination::Static => match self.operands.x_static() {
                Some(x_static) => Operand::Static(x_static),
                None => return Err(DestinationError::Static)
            },
            Destination::Dynamic => match self.operands.x_dynamic() {
                Some(x_dynamic) => Operand::Dynamic(x_dynamic.clone()),
                None => return Err(DestinationError::Dynamic)
            }
        })
    }
}

#[cfg(test)]
mod driver_test {
    use crate::Driver;

    #[test]
    fn extract_extension() {
        assert_eq!(Driver::extract_extension(0b001101_0_0), 0b00_001101);
        assert_eq!(Driver::extract_extension(0b101010_0_1), 0b00_101010);
    }

    #[test]
    fn set_extension() {
        assert_eq!(Driver::set_extension(0b000000_0_1, 0b001010), 0b001010_0_1);
        assert_eq!(Driver::set_extension(0b101100_0_0, 0b101100), 0b101100_0_0);
        assert_eq!(Driver::set_extension(0b101100_1_0, 0b101100), 0b101100_1_0);

        // Truncating extension
        assert_eq!(Driver::set_extension(0b00000000_0_0, 0b11_111111), 0b111111_0_0);
        assert_eq!(Driver::set_extension(0b00000000_0_1, 0b11_111110), 0b111110_0_1);
    }

    #[test]
    fn extract_synchronise() {
        assert!(Driver::extract_synchronise(0b000000_1_0));
        assert!(!Driver::extract_synchronise(0b000000_0_0));
        assert!(Driver::extract_synchronise(0b001010_1_1));
        assert!(!Driver::extract_synchronise(0b001010_0_1));
    }

    #[test]
    fn set_synchronise() {
        assert_eq!(Driver::set_synchronise(0b000000_0_0, true), 0b000000_1_0);
        assert_eq!(Driver::set_synchronise(0b000000_1_0, false), 0b000000_0_0);
        assert_eq!(Driver::set_synchronise(0b000000_0_1, true), 0b000000_1_1);
        assert_eq!(Driver::set_synchronise(0b111111_0_0, false), 0b111111_0_0);
    }

    #[test]
    fn extract_dynamic_destination() {
        assert!(Driver::extract_dynamic_destination(0b000000_0_1));
        assert!(!Driver::extract_dynamic_destination(0b000000_0_0));
        assert!(Driver::extract_dynamic_destination(0b000000_1_1));
        assert!(!Driver::extract_dynamic_destination(0b000000_1_0));
    }
    
    #[test]
    fn set_dynamic_destination() {
        assert_eq!(Driver::set_dynamic_destination(0b000000_0_0, true), 0b000000_0_1);
        assert_eq!(Driver::set_dynamic_destination(0b000000_1_0, true), 0b000000_1_1);
        assert_eq!(Driver::set_dynamic_destination(0b000000_0_1, false), 0b000000_0_0);
        assert_eq!(Driver::set_dynamic_destination(0b000000_1_1, false), 0b000000_1_0);
    }
    
    #[test]
    fn extract_operation() {
        assert_eq!(Driver::extract_operation(0b1101_00_00), 0b0000_1101);
        assert_eq!(Driver::extract_operation(0b1010_01_10), 0b0000_1010);
    }
    
    #[test]
    fn set_operation() {
        assert_eq!(Driver::set_operation(0b0001_00_11, 0b0000_1111), 0b1111_00_11);
        assert_eq!(Driver::set_operation(0b1111_00_10, 0b0000_1001), 0b1001_00_10);
        assert_eq!(Driver::set_operation(0b1010_00_10, 0b0000_1010), 0b1010_00_10);

        // Truncating extension
        assert_eq!(Driver::set_operation(0b0000_00_00, 0b1111_1111), 0b1111_00_00);
        assert_eq!(Driver::set_operation(0b0000_10_01, 0b1111_1111), 0b1111_10_01);
    }
    
    #[test]
    fn extract_addressing() {
        assert_eq!(Driver::extract_addressing(0b0011_10_00), 0b000000_10);
        assert_eq!(Driver::extract_addressing(0b1011_11_00), 0b000000_11);
        assert_eq!(Driver::extract_addressing(0b0000_00_00), 0b000000_00);
    }
    
    #[test]
    fn set_addressing() {
        assert_eq!(Driver::set_addressing(0b0000_11_00, 0b000000_00), 0b0000_00_00);
        assert_eq!(Driver::set_addressing(0b0011_00_00, 0b000000_01), 0b0011_01_00);
        assert_eq!(Driver::set_addressing(0b1011_00_00, 0b000000_00), 0b1011_00_00);

        // Truncating extension
        assert_eq!(Driver::set_addressing(0b0000_00_00, 0b111111_11), 0b0000_11_00);
        assert_eq!(Driver::set_addressing(0b1010_00_01, 0b111111_11), 0b1010_11_01);
    }
    
    #[test]
    fn extract_addressing_parameter() {
        assert_eq!(Driver::extract_addressing_parameter(0b0000_00_11), 0b000000_11);
        assert_eq!(Driver::extract_addressing_parameter(0b1010_11_01), 0b000000_01);
    }
    
    #[test]
    fn set_addressing_parameter() {
        assert_eq!(Driver::set_addressing_parameter(0b0011_00_00, 0b000000_11), 0b0011_00_11);
        assert_eq!(Driver::set_addressing_parameter(0b0000_11_00, 0b000000_10), 0b0000_11_10);
        assert_eq!(Driver::set_addressing_parameter(0b1011_01_00, 0b000000_00), 0b1011_01_00);

        // Truncating extension
        assert_eq!(Driver::set_addressing_parameter(0b0000_00_00, 0b111111_11), 0b0000_00_11);
        assert_eq!(Driver::set_addressing_parameter(0b1011_01_00, 0b111111_10), 0b1011_01_10);
    }
    
    #[test]
    fn from_encoded() {
        let driver0 = 0b001010_0_0;
        let driver1 = 0b1111_00_00;
        let driver = Driver::from_encoded([driver0, 0]);
        
        assert_eq!(driver.extension, 0b001010);
    }
}

#[cfg(test)]
mod instruction_test {
    use crate::{absolute, Destination, Instruction};
    use crate::operand::{AllPresent, Dynamic, Operand, Operands};
    use crate::operation::arithmetic::Arithmetic;
    use crate::operation::Extension;

    #[test]
    fn destination() {
        let mut instruction = Instruction {
            operation: Extension::Arithmetic(Arithmetic::Add),
            width: absolute::Type::Byte,
            destination: Destination::Static,
            operands: Operands::AllPresent(AllPresent {
                x_static: 10,
                x_dynamic: Dynamic::Constant(absolute::Data::Byte(5))
            })
        };
        
        assert!(matches!(instruction.destination().unwrap(), Operand::Static(_)));
    
        instruction.destination = Destination::Dynamic;
        assert!(!matches!(instruction.destination().unwrap(), Operand::Static(_)));
    }
}